---
title: "Python Crash Course"
subtitle: "Python Intro"
date: "2025-09-07"
---

## Learning outcomes

-   Describe the basic data types in programming
-   Use lists and dictionaries to store and retrieve data
-   Perform simple string operations
-   Use conditionals, loops and functions to create reusable blocks of code

## Basic datatypes & Operators

-   A **value** is a piece of data that a computer program works with such as a number or text.
-   There are different **types** of values: `42` is an integer and `"Hello!"` is a string.
-   A **variable** is a name that refers to a value.
    -   In mathematics and statistics, we usually use variables names like $x$ and $y$.
    -   In Python, we can use any word as a variable name (as long as it starts with a letter and is not a [reserved word](https://docs.python.org/3.3/reference/lexical_analysis.html#keywords) in Python such as `for`, `while`, `class`, `lambda`, etc.).
-   And we use the **assignment operator** `=` to assign a value to a variable.

See [Think Python (Chapter 2)](http://greenteapress.com/thinkpython/html/thinkpython003.html) for a discussion of variables, expressions and statements in Python.

### Common built-in Python data types

| English name | Type name | Description | Example |
|:-----------------|:-----------------|:-----------------|:-----------------|
| integer | `int` | positive/negative whole numbers | `42` |
| floating point number | `float` | real number in decimal form | `3.14159` |
| boolean | `bool` | true or false | `True` |
| string | `str` | text | `"I Can Has Cheezburger?"` |
| list | `list` | a collection of objects - mutable & ordered | `['Ali','Xinyi','Miriam']` |
| tuple | `tuple` | a collection of objects - immutable & ordered | `('Thursday',6,9,2018)` |
| dictionary | `dict` | mapping of key-value pairs | `{'name':'DSCI','code':511,'credits':2}` |
| none | `NoneType` | represents no value | `None` |

## Numeric Types

Here are some examples of declaring variables for numeric types. Note that unlike Java, Python is a loosely typed language that does not require the programmer to state the variable's type upon creation.

```{python}
x = 42
print(type(x))  # <class 'int'>

pi = 3.14159
print(type(pi))  # <class 'float'>

# Python supports Unicode variable names
Î» = 2
print(Î»)
```

### Arithmetic Operators

The syntax for the arithmetic operators are:

| Operator |   Description    |
|:--------:|:----------------:|
|   `+`    |     addition     |
|   `-`    |   subtraction    |
|   `*`    |  multiplication  |
|   `/`    |     division     |
|   `**`   |  exponentiation  |
|   `//`   | integer division |
|   `%`    |      modulo      |

Let's apply these operators to numeric types and observe the results. Use print statements to see the output

```{python}
1 + 2 + 3 + 4 + 5  # 15

0.1 + 0.2  # 0.30000000000000004 (floating point precision)

2 * 3.14159  # 6.28318

2**10  # 1024
type(2**10)  # <class 'int'>

2.0**10  # 1024.0 (float result)

101 / 2  # 50.5

101 // 2  # 50 ("integer division" - always rounds down)

101 % 2  # 1 ("101 mod 2", or the remainder when 101 is divided by 2)
```

### Operator Precedence

When you have multiple operators in an expression, Python has operator precedence rules that determine which operator is evaluated first. If the precedence priority is the same then we use the 'left to right' rule. This is similar to the BODMAS rule from mathematics.

| Precedence |          Group           | Operators                   |
|:----------:|:------------------------:|:----------------------------|
|     1      |       parenthesis        | `( )` `[ ]` `{ }`           |
|     2      |        exponents         | `**`                        |
|     3      | multiply, divide, modulo | `/` `*` `//` `%`            |
|     4      |  addition & subtraction  | `+` `-`                     |
|     5      |        comparison        | `>=` `<=` `>` `<`           |
|     6      |         equality         | `==` `!=`                   |
|     7      |        assignment        | `=` `+=` `-=` `/=` `*=`     |
|     8      |  identity & membership   | `is` `is not` `in` `not in` |
|     9      |         logical          | `and` `or` `not`            |

Observe how the placement of parentheses impacts the result:

```{python}
4 + 6 * 7    # 46 (multiplication first)
(4 + 6) * 7  # 70 (parentheses force addition first)
4 + (6 * 7)  # 46 (explicitly showing default precedence)
```

## None

-   `NoneType` is its own type in Python.
-   It only has one possible value, `None`

```{python}
x = None
print(x)     # None
type(x)      # <class 'NoneType'>
```

You may have seen similar things in other languages, like `null` in Java.

## Boolean

The Boolean (`bool`) type has two values: `True` and `False`.

```{python}
the_truth = True
print(the_truth)  # True
type(the_truth)   # <class 'bool'>

lies = False
print(lies)       # False
```

### Comparison Operators

Compare objects using comparison operators. The result is a Boolean value.

| Operator | Description                          |
|:--------:|:-------------------------------------|
| `x == y` | is `x` equal to `y`?                 |
| `x != y` | is `x` not equal to `y`?             |
| `x > y`  | is `x` greater than `y`?             |
| `x >= y` | is `x` greater than or equal to `y`? |
| `x < y`  | is `x` less than `y`?                |
| `x <= y` | is `x` less than or equal to `y`?    |
| `x is y` | is `x` the same object as `y`?       |

```{python}
print(2 < 3)  # True

print("Data Science" != "Deep Learning")  # True

print(2 == "2")  # False (different types)

2 == 2.0  # True (same value, different types)
```

### Operators for Boolean values

| Operator  | Description                          |
|:---------:|:-------------------------------------|
| `x and y` | are `x` and `y` both true?           |
| `x or y`  | is at least one of `x` and `y` true? |
|  `not x`  | is `x` false?                        |

```{python}
True and True   # True
True and False  # False
False or False  # False

("Python 2" != "Python 3") and (2 <= 3)  # True

not True        # False
not not True    # True
```

## Casting

Sometimes we need to explicitly **cast** a value from one type to another. Python tries to do something reasonable, or throws an error if it can't figure out what to do.

```{python}
x = int(5.0)     # 5
type(x)          # <class 'int'>

x = str(5.0)     # '5.0'
type(x)          # <class 'str'>

str(5.0) == 5.0  # False (string vs number)

int(5.3)         # 5 (truncates decimal)

# This will cause an error:
# list(5.0)      # TypeError: 'float' object is not iterable
```

## Strings

-   Text is stored as a type called a string.
-   We think of a string as a sequence of characters.
-   We write strings as characters enclosed with either:
    -   single quotes, e.g., `'Hello'`
    -   double quotes, e.g., `"Goodbye"`
    -   triple single quotes, e.g., `'''Yesterday'''`
    -   triple double quotes, e.g., `"""Tomorrow"""`

```{python}
my_name = "Oluwakemi Olamudzengi"
course = 'DSCI 320'
```

If the string contains a quotation or apostrophe, we can use double quotes or triple quotes to define the string.

```{python}
sentence = "It's a snowy day."

saying = '''They say:
"It's a snowy day!"'''
print(saying)
# They say:
# "It's a snowy day!"
```

### Essential String Methods

There are many useful string methods in Python. Here are the most commonly used ones:

```{python}
text = "HOW ARE YOU TODAY?"

# Convert case
text.lower()    # "how are you today?"
text.upper()    # "HOW ARE YOU TODAY?"

# Split into words
text.split()    # ['HOW', 'ARE', 'YOU', 'TODAY?']

# Count occurrences
text.count("O") # 4

# Replace text
text.replace("HOW", "Why")  # "Why ARE YOU TODAY?"
```

Note that string methods don't change the original string but return a new one (strings are immutable).

You can convert a string to a list of characters:

```{python}
word = "Python"
list(word)  # ['P', 'y', 't', 'h', 'o', 'n']
len(word)   # 6
```

### Python String Methods Reference

Here are some common string methods that may prove beneficial when cleaning datasets.

#### Case Conversion Methods

| Method | Description | Example | Result |
|------------------|--------------------|------------------|------------------|
| `str.lower()` | Convert to lowercase | `"HELLO".lower()` | `"hello"` |
| `str.upper()` | Convert to uppercase | `"hello".upper()` | `"HELLO"` |
| `str.capitalize()` | Capitalize first letter only | `"hello world".capitalize()` | `"Hello world"` |
| `str.title()` | Capitalize first letter of each word | `"hello world".title()` | `"Hello World"` |

#### Searching and Testing Methods

| Method | Description | Example | Result |
|------------------|--------------------|------------------|------------------|
| `str.find(sub)` | Find first index of substring (-1 if not found) | `"hello".find("ell")` | `1` |
| `str.rfind(sub)` | Find last index of substring | `"hello hello".rfind("ell")` | `7` |
| `str.index(sub)` | Like find() but raises error if not found | `"hello".index("ell")` | `1` |
| `str.count(sub)` | Count occurrences of substring | `"hello hello".count("ell")` | `2` |
| `str.startswith(prefix)` | Check if string starts with prefix | `"hello".startswith("he")` | `True` |
| `str.endswith(suffix)` | Check if string ends with suffix | `"hello".endswith("lo")` | `True` |
| `sub in str` | Check if substring exists | `"ell" in "hello"` | `True` |

#### Character Type Testing Methods

| Method | Description | Example | Result |
|------------------|--------------------|------------------|------------------|
| `str.isalpha()` | True if all characters are letters | `"hello".isalpha()` | `True` |
| `str.isdigit()` | True if all characters are digits | `"123".isdigit()` | `True` |
| `str.isalnum()` | True if all characters are letters or digits | `"hello123".isalnum()` | `True` |
| `str.isspace()` | True if all characters are whitespace | `"   ".isspace()` | `True` |
| `str.islower()` | True if all letters are lowercase | `"hello".islower()` | `True` |
| `str.isupper()` | True if all letters are uppercase | `"HELLO".isupper()` | `True` |

#### Splitting and Joining Methods

| Method | Description | Example | Result |
|------------------|--------------------|------------------|------------------|
| `str.split(sep)` | Split string into list | `"a,b,c".split(",")` | `['a', 'b', 'c']` |
| `str.split()` | Split on any whitespace | `"a b  c".split()` | `['a', 'b', 'c']` |
| `str.rsplit(sep, maxsplit)` | Split from right side | `"a.b.c".rsplit(".", 1)` | `['a.b', 'c']` |
| `str.splitlines()` | Split on line breaks | `"a\nb\nc".splitlines()` | `['a', 'b', 'c']` |
| `str.join(iterable)` | Join elements with string as separator | `"-".join(['a', 'b', 'c'])` | `"a-b-c"` |

#### Cleaning and Trimming Methods

| Method | Description | Example | Result |
|------------------|--------------------|------------------|------------------|
| `str.strip()` | Remove whitespace from both ends | `"  hello  ".strip()` | `"hello"` |
| `str.lstrip()` | Remove whitespace from left end | `"  hello  ".lstrip()` | `"hello  "` |
| `str.rstrip()` | Remove whitespace from right end | `"  hello  ".rstrip()` | `"  hello"` |
| `str.strip(chars)` | Remove specific characters from ends | `"...hello...".strip(".")` | `"hello"` |

#### Replacement and Transformation Methods

| Method | Description | Example | Result |
|------------------|--------------------|------------------|------------------|
| `str.replace(old, new)` | Replace all occurrences | `"hello world".replace("l", "x")` | `"hexxo worxd"` |
| `str.replace(old, new, count)` | Replace first n occurrences | `"hello world".replace("l", "x", 2)` | `"hexxo world"` |

## Lists and Tuples

Lists and tuples allow us to store multiple things (elements) in a single object. The elements are ordered.

```{python}
my_list = [1, 2, "THREE", 4, 0.5]
print(my_list)  # [1, 2, 'THREE', 4, 0.5]
type(my_list)   # <class 'list'>

len(my_list)    # 5
```

### Tuples

A tuple is very similar to a list, but the main difference is that it is **immutable** - once created, you cannot add or remove elements.

```{python}
coordinates = (1, 2, "THREE", 4, 0.5)
print(coordinates)  # (1, 2, 'THREE', 4, 0.5)
type(coordinates)   # <class 'tuple'>
```

### Indexing and Slicing Sequences

We can access values inside lists, tuples, or strings using bracket syntax. Python uses zero-based indexing, which means the first element is at position 0.

```{python}
my_list = [1, 2, "THREE", 4, 0.5]

my_list[0]  # 1 (first element)
my_list[4]  # 0.5 (last element)
my_list[-1] # 0.5 (negative indices count from the end)
my_list[-2] # 4

# my_list[5]  # IndexError: list index out of range
```

We use the colon `:` to access a subsequence. This is called "slicing":

```{python}
my_list[1:4]  # [2, 'THREE', 4] (start inclusive, end exclusive)
my_list[:3]   # [1, 2, 'THREE'] (from beginning to index 3)
my_list[3:]   # [4, 0.5] (from index 3 to end)
my_list[:]    # [1, 2, 'THREE', 4, 0.5] (entire list, creates a copy)
```

Strings work the same way for indexing and slicing:

```{python}
alphabet = "abcdefghijklmnopqrstuvwxyz"
alphabet[0]     # 'a'
alphabet[-1]    # 'z'
alphabet[:5]    # 'abcde'
alphabet[12:20] # 'mnopqrst'
```

### Mutability: Lists vs Tuples vs Strings

**Mutable types** (like lists) can be modified after creation:

```{python}
names_list = ["Desi", "Fang", "Ahmed"]
names_list[0] = "Cool guy"  # This works
print(names_list)  # ['Cool guy', 'Fang', 'Ahmed']
```

**Immutable types** (like tuples and strings) cannot be modified:

```{python}
names_tuple = ("Indiana", "Fang", "Linsey")
# names_tuple[0] = "Not cool guy"  # TypeError: 'tuple' object does not support item assignment

my_name = "Kemi"
# my_name[-1] = 'q'  # TypeError: 'str' object does not support item assignment
```

However, if a tuple contains mutable objects, those objects can still be modified:

```{python}
x = ([1, 2, 3], 5)
# x[1] = 7        # Error: can't reassign tuple elements
x[0][1] = 4       # OK: can modify the list inside the tuple
print(x)          # ([1, 4, 3], 5)
```

### List Methods

Lists have methods for interacting with their data. See the [documentation](https://docs.python.org/3/tutorial/datastructures.html#more-on-lists) for more list methods.

```{python}
primes = [2, 3, 5, 7, 11]

# Add elements
primes.append(13)    # [2, 3, 5, 7, 11, 13]

# Useful functions with lists
len(primes)          # 6
max(primes)          # 13
min(primes)          # 2
sum(primes)          # 41

# Combine lists
[1, 2, 3] + ["Hello", 7]  # [1, 2, 3, 'Hello', 7]
```

#### Adding Elements

| Method | Description | Example | Result |
|------------------|--------------------|------------------|------------------|
| `list.append(item)` | Add single item to end | `[1, 2].append(3)` | `[1, 2, 3]` |
| `list.insert(index, item)` | Insert item at specific position | `[1, 3].insert(1, 2)` | `[1, 2, 3]` |
| `list + list` | Concatenate lists (creates new list) | `[1, 2] + [3, 4]` | `[1, 2, 3, 4]` |

#### Removing Elements

| Method | Description | Example | Result |
|------------------|--------------------|------------------|------------------|
| `list.remove(item)` | Remove first occurrence of item | `[1, 2, 1].remove(1)` | `[2, 1]` |
| `list.pop()` | Remove and return last item | `[1, 2, 3].pop()` | Returns `3`, list becomes `[1, 2]` |
| `del list[index]` | Delete item at index | `del lst[0]` | Removes first item |
| `del list[start:end]` | Delete slice of items | `del lst[1:3]` | Removes items at indices 1 and 2 |

#### Finding and Counting

| Method | Description | Example | Result |
|------------------|--------------------|------------------|------------------|
| `list.index(item)` | Find index of first occurrence | `[1, 2, 3, 2].index(2)` | `1` |
| `list.count(item)` | Count occurrences of item | `[1, 2, 2, 3].count(2)` | `2` |
| `item in list` | Check if item exists | `2 in [1, 2, 3]` | `True` |
| `item not in list` | Check if item doesn't exist | `4 not in [1, 2, 3]` | `True` |

#### Sorting and Reversing

| Method | Description | Example | Result |
|------------------|--------------------|------------------|------------------|
| `list.sort()` | Sort list in place (ascending) | `[3, 1, 2].sort()` | `[1, 2, 3]` |
| `list.sort(reverse=True)` | Sort list in place (descending) | `[1, 3, 2].sort(reverse=True)` | `[3, 2, 1]` |
| `list.reverse()` | Reverse list in place | `[1, 2, 3].reverse()` | `[3, 2, 1]` |
| `sorted(list)` | Return new sorted list | `sorted([3, 1, 2])` | `[1, 2, 3]` (original unchanged) |

#### Copying Lists

| Method | Description | Example | Result |
|------------------|--------------------|------------------|------------------|
| `list.copy()` | Create shallow copy | `[1, 2, 3].copy()` | `[1, 2, 3]` (new list) |
| `list[:]` | Slice copy (shallow) | `[1, 2, 3][:]` | `[1, 2, 3]` (new list) |
| `list(original)` | Constructor copy (shallow) | `list([1, 2, 3])` | `[1, 2, 3]` (new list) |
| `copy.deepcopy(list)` | Create deep copy | `copy.deepcopy([[1, 2], [3, 4]])` | Deep copy of nested structures |

#### Built-in Functions for Lists

| Function    | Description           | Example          | Result |
|-------------|-----------------------|------------------|--------|
| `len(list)` | Get length of list    | `len([1, 2, 3])` | `3`    |
| `max(list)` | Find maximum value    | `max([1, 3, 2])` | `3`    |
| `min(list)` | Find minimum value    | `min([1, 3, 2])` | `1`    |
| `sum(list)` | Sum all numeric items | `sum([1, 2, 3])` | `6`    |

#### List Indexing and Slicing

| Operation | Description | Example | Result |
|------------------|-------------------|------------------|------------------|
| `list[index]` | Access item by index | `[1, 2, 3][1]` | `2` |
| `list[-index]` | Access from end (negative indexing) | `[1, 2, 3][-1]` | `3` |
| `list[start:end]` | Slice from start to end-1 | `[1, 2, 3, 4][1:3]` | `[2, 3]` |
| `list[start:]` | Slice from start to end | `[1, 2, 3, 4][2:]` | `[3, 4]` |
| `list[:end]` | Slice from beginning to end-1 | `[1, 2, 3, 4][:2]` | `[1, 2]` |
| `list[::step]` | Slice with step | `[1, 2, 3, 4, 5][::2]` | `[1, 3, 5]` |
| `list[::-1]` | Reverse slice | `[1, 2, 3][::-1]` | `[3, 2, 1]` |

### Sets

Another built-in Python data type is the `set`, which stores an unordered collection of unique items.

```{python}
s = {2, 3, 5, 11}
print(s)  # {2, 3, 5, 11}

{1, 2, 3} == {3, 2, 1}  # True (order doesn't matter)
[1, 2, 3] == [3, 2, 1]  # False (order matters for lists)

s.add(2)  # Does nothing (2 already exists)
# s[0]    # TypeError: 'set' object is not subscriptable (no indexing)
```

### Creating Empty Structures

```{python}
# Empty structures
empty_list = []        # or list()
empty_tuple = ()       # or tuple()
empty_dict = {}        # or dict()
empty_set = set()      # Note: {} creates a dict, not a set!

# Check types
type({})     # <class 'dict'>
type({1})    # <class 'set'>
```

## Dictionaries

A dictionary is a mapping between key-value pairs, perfect for storing related information.

```{python}
house = {
    'bedrooms': 3, 
    'bathrooms': 2, 
    'city': 'Vancouver', 
    'price': 2499999, 
    'date_sold': (1, 3, 2015)
}

condo = {
    'bedrooms': 2, 
    'bathrooms': 1, 
    'city': 'Burnaby', 
    'price': 699999, 
    'date_sold': (27, 8, 2011)
}
```

We can access specific fields with square brackets:

```{python}
house['price']  # 2499999
condo['city']   # 'Burnaby'
```

Dictionaries are mutable - we can edit them:

```{python}
condo['price'] = 750000        # Update existing key
condo['flooring'] = "wood"     # Add new key
del condo["city"]              # Remove a key (rarely used)
```

### Handling Missing Keys

```{python}
# This causes an error:
# condo["nonexistent"]  # KeyError: 'nonexistent'

# Safe way with default values:
condo.get("bedrooms")           # 2 (key exists)
condo.get("bedrooms", "unknown") # 2 (key exists, default ignored)
condo.get("fireplaces", "unknown") # 'unknown' (key doesn't exist, returns default)
```

### Finding Maximum by Value

A common operation is finding the dictionary key with the maximum value:

```{python}
scores = {'Alice': 100, 'Bob': 3000, 'Charlie': 1500, 'Diana': 340}
max(scores, key=scores.get)  # 'Bob' (has highest score)

# Without key parameter, it finds max key alphabetically:
max(scores)  # 'Diana'
```

## Conditionals

[Conditional statements](https://docs.python.org/3/tutorial/controlflow.html) allow us to write programs where only certain blocks of code are executed depending on the state of the program. <br>Check out [Think Python (Chapter 5)](http://greenteapress.com/thinkpython/html/thinkpython006.html) for more information about conditional execution.

```{python}
name = input("What's your name? ")

if name.lower() == 'mike':
    print("That's my name too!")
elif name.lower() == 'santa':
    print("That's a funny name.")
else:
    print("Hello {}! That's a cool name.".format(name))
    print('Nice to meet you!')
```

The main points to notice:

-   Use keywords `if`, `elif` and `else`
-   The colon `:` ends each conditional expression
-   Indentation (by 4 spaces) defines code blocks
-   In an `if` statement, the first block whose condition returns `True` is executed and the program exits the `if` block
-   `if` statements don't necessarily need `elif` or `else`
-   `elif` lets us check several conditions
-   `else` lets us evaluate a default block if all other conditions are `False`

If statements can also be **nested** inside one another:

```{python}
temperature = 25

if temperature > 30:
    print("It's hot!")
    if temperature > 40:
        print("Stay indoors!")
elif temperature < 0:
    print("It's freezing!")
else:
    print("Nice weather!")
```

### Inline if/else

For simple conditions, you can use a compact inline format:

```{python}
words = ["the", "list", "of", "words"]

status = "long list" if len(words) > 10 else "short list"
# Equivalent to:
# if len(words) > 10:
#     status = "long list"
# else:
#     status = "short list"
```

### Short-circuiting (Optional)

Python evaluates boolean expressions efficiently by "short-circuiting":

```{python}
# BLAH  # This would cause a NameError if evaluated

True or BLAH   # True (BLAH never evaluated)
False and BLAH # False (BLAH never evaluated)
# True and BLAH # Would cause NameError (BLAH gets evaluated)
```

## Loops

Loops allow us to execute a block of code multiple times.

### For Loops

```{python}
for n in [2, 7, -1, 5]:
    print("The number is", n, "its square is", n**2)
    # this is inside the loop
# this is outside the loop
```

The main points to notice:

-   Keyword `for` begins the loop
-   Colon `:` ends the first line of the loop
-   We can iterate over any iterable: list, tuple, range, string
-   Block of code (indented) is executed for each value in the list
-   The loop ends after the variable has taken all values in the list

```{python}
word = "Python"
for letter in word:
    print("Gimme a " + letter + "!")
print("What's that spell?!! " + word + "!")
```

A very common pattern is to use `for` with `range`, which gives you a sequence of integers:

```{python}
for i in range(10):      # 0 through 9
    print(i)

for i in range(1, 101, 10):  # start, stop, step
    print(i)             # 1, 11, 21, 31, 41, 51, 61, 71, 81, 91
```

**Nested loops** iterate over multiple dimensions:

```{python}
for x in [1, 2, 3]:
    for y in ["a", "b", "c"]:
        print((x, y))
# Prints: (1, 'a'), (1, 'b'), (1, 'c'), (2, 'a'), (2, 'b'), (2, 'c'), (3, 'a'), (3, 'b'), (3, 'c')
```

**Parallel iteration** with multiple lists:

```{python}
numbers = [1, 2, 3]
letters = ["a", "b", "c"]
for i in range(3):
    print(numbers[i], letters[i])
```

**Dictionary iteration** using `.items()`:

```{python}
courses = {
    320: "cool",
    430: "awesome",
    200: "riveting", 
    100: "naptime"
}

for course_num, description in courses.items():
    print("DSCI", course_num, "is", description)

# Alternative: iterate over keys only
for course_num in courses:
    print(course_num, courses[course_num])
```

### While Loops

We can also use a `while` loop to execute a block of code several times. These are less common in data science work.

**Warning**: If the condition is always `True`, you'll get an infinite loop! Use Ctrl-C to stop if this happens.

```{python}
n = 10
while n > 0:
    print(n)
    n = n - 1
print("Blast off!")
```

## Functions

A function is a block of code that has been encapsulated so that it can be reused. Functions can have different input parameters or be defined without any. In Python, we define functions with the `def` keyword.

```{python}
def calculate_area(shape, measurement):
    """Calculate area of different shapes."""
    if shape == 'circle':
        area = 3.14159 * measurement ** 2
        return f"The area of the {shape} is {area}"
    elif shape == 'square':
        area = measurement ** 2
        return f"The area of the {shape} is {area}"
    else:
        return f"Unknown shape: {shape}"

# Using the function
print(calculate_area('circle', 4))   # The area of the circle is 50.26544
print(calculate_area('square', 4))   # The area of the square is 16
print(calculate_area('triangle', 4)) # Unknown shape: triangle
```

Key points about functions:

-   Function block is defined by indentation
-   Output or "return" value is given by the `return` keyword
-   If no `return` statement, the function returns `None`
-   Functions can have parameters (inputs) and return values (outputs)
-   The docstring (optional) describes what the function does

## Import

It is often useful to collect classes and functions into **modules** or **packages** ([Python package documentation](https://docs.python.org/3/tutorial/modules.html#packages)). For example, numpy is a package that contains classes (e.g. `np.ndarray`), functions (e.g. `np.sqrt`), and constants (e.g. `np.pi`).

```{python}
# Import entire package
import numpy
numpy.sqrt(6)  # 2.449489742783178

# Import with alias (very common)
import numpy as np
np.sqrt(6)     # 2.449489742783178

# Import specific function
from numpy.random import randn
randn()        # -0.5234523 (random number)
```

## Summary

You now have the fundamental building blocks of Python programming:

-   **Data types**: numbers, strings, booleans, lists, tuples, dictionaries, sets
-   **Methods**: string and list methods
-   **Operations**: arithmetic, comparison, boolean logic
-   **Control flow**: conditionals (`if`/`elif`/`else`) and loops (`for`/`while`)
-   **Functions**: reusable blocks of code
-   **Imports**: using external libraries

These concepts form the foundation for more advanced Python programming and data science work. Practice combining these elements to solve real-world problems, and don't hesitate to experiment with the code examples!

## Next Steps

Work through the next file to ensure that you have understood the basics of python

```{python}

## Attribution

Adapted from the MDS curriculum
```